{"componentChunkName":"component---src-templates-docs-js","path":"/why-containers","result":{"data":{"site":{"siteMetadata":{"title":"Docker Workshop | Tommy May III","docsLocation":""}},"mdx":{"fields":{"id":"3e1573a3-132e-578d-9039-fc99300a4968","title":"Why Use Containers","slug":"/why-containers"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Why Use Containers\",\n  \"metaTitle\": \"Why Use Containers\",\n  \"metaDescription\": \"Containers, docker especially, are the hot technology right now but what makes them so popular and why should we use them\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"The Problem Containers Solve\"), mdx(\"h2\", null, \"1. Dev/Prod Parity\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://12factor.net/dev-prod-parity\"\n  }), \"Dev/Prod Parity\")), mdx(\"p\", null, \"Containers allow developers to run code on the same infrastructure that our production environments use. This is because\\napplication infrastructure is paired with the application code itself.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"i.e.\"), \" If your website has redirects that you are managing with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.nginx.com/\"\n  }), \"Nginx\"), \", then the edits to the\\nNginx configuration will be made locally. If the change works locally you have a guarantee that it will also work in\\nproduction. This is opposed to running Nginx on your local machine where you would make a change locally and then have\\nto tell some systems engineer to make the same change in an elevated environment. Even if the person that makes the\\nchange locally and in the elevated environment are the same person there would be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"NO\"), \" guarantee that the Nginx running\\nlocally and in production will be configured the same.\"), mdx(\"p\", null, \"It is nice to think of a container similar to a JVM where you have a guarantee your Java code will run the same on\\nWindows, Linux, and MacOS.\"), mdx(\"h2\", null, \"2. Scalability\"), mdx(\"p\", null, \"Containers are extremely lightweight compared to VMs. This is because containers share the host operating system while VMs\\nhave their own operating system. This often means that you can run hundreds of containers on a modestly sized computer\\nwithout noticing much of a performance impact. Obviously this leads to faster startup times to get new containers up and\\nrunning as well as reduced server costs as you can run more applications running on 1 server.\"), mdx(\"h2\", null, \"3. Easy to Upgrade\"), mdx(\"p\", null, \"If you are managing infrastructure manually today either by SSHing into servers or using some provisioning tool like\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.ansible.com/\"\n  }), \"ansible\"), \" or \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://puppet.com/\"\n  }), \"puppet\"), \" then you have probably experienced some headaches\\nof deployments not working the same way on every server. Sometimes these tools will leave your application in a half\\nconfigured upgrade if something fails unexpectedly like the network connection. It can take a lot of work to make your\\ndeployment scripts resilient to change by having rollback actions setup and staging your changes correctly before actually\\ncommitting them.\"), mdx(\"p\", null, \"With containers all the issues you have with staging changes and rolling back every action just do not exist. Often an\\nupgrade with a tool like Docker will be changing the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.docker.com/engine/reference/builder/\"\n  }), \"Dockerfile\"), \"\\nfrom nginx:1.16.0 to nginx:1.18.0. If for some reason the deployment fails then your rollback strategy is often simply\\nchanging the version numbers back. This is made possible because containers, more specifically images, are immutable.\\nWhen you deploy you are not modifying existing infrastructure but instead provisioning new infrastructure and then removing\\nthe old from the network.\"), mdx(\"h1\", null, \"Containers vs VMs\"), mdx(\"p\", null, \"Containers are isolated, lightweight processes that take advantages of the host operation system's kernel. VMs run a\\nstandalone operating system which includes its own kernel.\"), mdx(\"p\", null, \"We are not going to focus on the lower level differences between these two technologies. I would suggest reading some\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/containers-vs-vm\"\n  }), \"offical docs\"), \" on the topic. It\\nis just important for you to know that these two technologies are not exclusive. It is very common to be using these technologies\\ntogether especially in elevated environments. Take a look at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/\"\n  }), \"Kubernetes\"), \"\\nfor instance where the \\\"nodes\\\" are essentially VMs and the \\\"pods\\\" are usually containers running on top of the nodes.\"), mdx(\"h1\", null, \"Images and Immutability\"), mdx(\"p\", null, \"You might hear people talking about how containers are immutable. What those people really mean is that images are immutable.\"), mdx(\"p\", null, \"We have not talked about images until this point so let's go over what an image is:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read-only template with instructions for creating a Docker container.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Images are often based on other images i.e. the bitnami/laravel image is likely based off of the PHP image.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Created with \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.docker.com/engine/reference/builder/\"\n  }), \"Dockerfiles\"), \".\")), mdx(\"p\", null, \"Containers themselves can be thought of as an instance of an image. When we hear people talking about immutability it means\\nthat when creating containers from images you are guaranteed to get identical containers from the same image.\"), mdx(\"h2\", null, \"Why Do We Care About Immutability\"), mdx(\"p\", null, \"Imagine what would happen if we could not guarantee the state of each container. A production ready application might be\\nrunning hundreds of application instances (containers). If every instance of the application could be different, then each\\nrequest that is handled by the cluster of applications could potentially give a different result. With each instance of\\nthe application being identical we can find comfort in knowing bugs are not likely to pop up in just 1 instance. If\\nwe find a bug then it likely exists on every instance and therefore easier to debug and squash. Compare this to the days\\nbefore containers were mainstream, where you would always be uncertain if one of your many servers was mis-configured.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#the-problem-containers-solve","title":"The Problem Containers Solve","items":[{"url":"#1-devprod-parity","title":"1. Dev/Prod Parity"},{"url":"#2-scalability","title":"2. Scalability"},{"url":"#3-easy-to-upgrade","title":"3. Easy to Upgrade"}]},{"url":"#containers-vs-vms","title":"Containers vs VMs"},{"url":"#images-and-immutability","title":"Images and Immutability","items":[{"url":"#why-do-we-care-about-immutability","title":"Why Do We Care About Immutability"}]}]},"parent":{"relativePath":"why-containers.md"},"frontmatter":{"metaTitle":"Why Use Containers","metaDescription":"Containers, docker especially, are the hot technology right now but what makes them so popular and why should we use them"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/containers-in-practice","title":"Containers in Practice"}}},{"node":{"fields":{"slug":"/quick-examples","title":"Quick Examples"}}},{"node":{"fields":{"slug":"/","title":"Docker Workshop"}}},{"node":{"fields":{"slug":"/why-containers","title":"Why Use Containers"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/containers-in-practice/1-managing-docker-containers","title":"Managing Docker Containers"}}},{"node":{"fields":{"slug":"/containers-in-practice/2-building-an-image","title":"Building an Image"}}},{"node":{"fields":{"slug":"/containers-in-practice/3-docker-compose","title":"Docker Compose"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"3e1573a3-132e-578d-9039-fc99300a4968"}}}